## Semantic rules TODOs
- [x] Interfaces and components define their own scope.
- [x] Interfaces and components cannot be nested.
- [x] There is a global scope that contains interface and component declarations.
- [x] The declarations inside the global scope are mutually recursive.
- [x] A component must implement all the members defined in the interfaces it provides (the types of the members must be the same).
- [x] The declarations inside a component are mutually recursive.
- [x] The interfaces used by a component must not lead to *ambiguous* names, i.e. names provided by different used interfaces.
- [x] A component can only provides and uses interfaces.
- [x] The name of an interface must occur only once in a `provides` and `uses` list.
- [x] A component may provide two interfaces that have members with the same name as long as these members have the same type.
- [x] Block can be nested and the declaration of a variable `x` in a inner block hides possible declarations in outer blocks.
- [x] Functions cannot be nested.
- [x] No function overloading.
- [x] The interface `App` can be provided by only one component and never used.
- [x] There exists a `Prelude` component that provides two library functions to perform I/O operations: *print(v : int)* and *getint() : int*. The `Prelude` interface is implicitly used by all components, and it cannot be provided by any component. 

## Typing rules TODOs
- [x] Booleans and characters cannot be converted to integers.
- [x] References to arrays and references to scalars are different types.
- [x] Arithmetic operators expect only integer values.
- [x] Logical operators expect only boolean values.
- [x] In `a[i]` we expect `a` to be an array or a reference to an array and `i` to be an integer value.
- [x] Only functions can be invoked.
- [x] A function call must provides a number of arguments equals to the parameters of the function.
- [x] Conditional guards in `if`, `while` and `for` statements expect boolean values.
- [x] Array should have a size of at least 1 element.
- [x] Array cannot be assigned, i.e., `array1 = array2` is not allowed.
- [ ] Array references can occur only as formal parameters.
- [x] Variables of type `void` are not allowed.
- [x] References `T&` requires that `T` is a scalar type.
- [x] Currently, functions can only return `int`, `bool`, `char` and `void`.
- [x] Multi-dimensional arrays are not supported.
- [x] References `T&` supports automatic dereference: when a reference does not occur in the left hand-side of an assignment, it is automatically dereferenced and its type is `T`.
- [x] When a reference `x` of type `T&` is on the left hand-side of an assignment, the semantics of the assignment depends on the type of the expression `e` on right hand-side: 
  - [x] If `e` has type `T&`, the assignment is well typed and its execution changes the address `x` points to with the address resulting from the evaluation of `e`.
  - [x] If `e` has type `T`, the assignment is well typed and its evaluation modifies the memory location pointed by `x` with the result of `e`.